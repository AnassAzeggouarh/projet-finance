---
title: "Construction d'un portefeuille optimisé en R"
author: "Anass Azeggouarh-Wallen et Mamadou Giuliano"
date: "2025-01-10"
output: ioslides_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## 1. Présentaton du sujet

## 

**Pourquoi ce sujet ?**

Passionnés par la finance, nous avons voulu explorer l'optimisation des rendements tout en minimisant les risques, en utilisant le modèle moyenne/variance de Markowitz, abordé avec M. Donze.

**Pourquoi ces entreprises ?**

-   **Apple** : Leader en technologie grand public.
-   **Walmart** : Géant de la grande distribution américaine.
-   **Meta** : Croissance rapide dans le numérique.
-   **Nvidia** : Forte demande dans l’IA et semi-conducteurs + révélation sur les marchés en 2025.

Cette période (2024-2025) est marquée par une forte hausse du S&P 500 (+24/27% en 2025), offrant un cadre intéressant pour l'analyse.

## 2. Le modèle

## 2.1 Évolution des actions (Base 100)

```{r include=FALSE}
# Charger les librairies
library(quantmod)
library(quadprog)
# Télécharger les données
tickers <- c("AAPL", "WMT", "META", "NVDA")
getSymbols(tickers, src = "yahoo", from = "2024-01-01", to = "2025-01-01")

# Préparer les données
prices <- merge(
  AAPL[, "AAPL.Adjusted"],
  WMT[, "WMT.Adjusted"],
  META[, "META.Adjusted"],
  NVDA[, "NVDA.Adjusted"]
)
colnames(prices) <- c("apple", "walmart", "meta", "nvidia")

# Calcul des bases 100
Apple_100 <- prices[, "apple"] / as.vector(prices[1, "apple"]) * 100
Walmart_100 <- prices[, "walmart"] / as.vector(prices[1, "walmart"]) * 100
Meta_100 <- prices[, "meta"] / as.vector(prices[1, "meta"]) * 100
Nvidia_100 <- prices[, "nvidia"] / as.vector(prices[1, "nvidia"]) * 100

# Graphique
png("graphique_base_100.png", width = 800, height = 600)
plot(
  Apple_100, type = "l", col = "blue", lwd = 2,
  xlab = "Date", ylab = "Base 100", main = "Évolution des actions (Base 100)"
)
lines(Walmart_100, col = "purple", lwd = 2)
lines(Meta_100, col = "cyan", lwd = 2)
lines(Nvidia_100, col = "yellow", lwd = 2)
legend(
  "topleft", legend = c("Apple", "Walmart", "Meta", "Nvidia"),
  col = c("blue", "purple", "cyan", "yellow"), lty = 1, cex = 0.8
)
dev.off()
```

![](/Users/anassazeggouarh/Documents/TD%20programmation/base100M1.png){width="70%"}

NVIDIA se distingue comme l'actif le plus performant en 2024 selon sa base 100. Cette performance exceptionnelle reflète la forte demande en IA, qui a propulsé ses résultats financiers à des sommets historiques. L'entreprise a également consolidé sa position de leader des semi-conducteurs.

## 2.2 calcul des rendements et de la volatilité

```{r include=FALSE}
returns <- na.omit(ROC(prices, type = "discrete"))
colnames(returns) <- c("apple", "walmart", "meta", "nvidia")
summary(returns)

plot(
  returns[, "apple"], type = "l", col = "blue", ylim = range(returns),
  xlab = "Temps", ylab = "Rendements", main = "Rendements des actions"
)
lines(returns[, "walmart"], col = "purple")
lines(returns[, "meta"], col = "cyan")
lines(returns[, "nvidia"], col = "yellow")

legend(
  "topleft", legend = c("Apple", "Walmart", "Meta", "Nvidia"),
  col = c("blue", "purple", "cyan", "yellow"), lty = 1, cex = 0.8
)
```

![](/Users/anassazeggouarh/Documents/TD%20programmation/rendementsM1.png) 

On observe à travers le graphique que Nvidia est l’actif le plus volatile.

## 2.4 ratio de sharpe

**rendements moyens journaliers :**

```{r echo=FALSE}
mean_returns <- colMeans(returns)
mean_returns
```

**volatilité moyenne journalière :**

```{r echo=FALSE}
std_returns <- apply(returns, 2, sd)  
std_returns
```

**ratio de sharpe par actif rendements/écart-type):**

```{r echo=FALSE}
ratio_sharpe <- mean_returns/std_returns
ratio_sharpe
```

## 3. Programme d'optimisation

## 3.1 histoire et Hypothèses du modèle de markowitz

-   **Origine** : Développé par H.Markowitz en 1952, ce modèle vise à maximiser les rendements pour un risque donné ou à minimiser le risque pour un rendement souhaité. Il repose sur l'idée clé de diversification pour réduire le risque global du portefeuille.
-   **Hypothèses** :
    -   Les rendements sont supposés normaux, et le risque est mesuré par l’écart-type.\
    -   Les actifs ne sont pas parfaitement corrélés, permettant une diversification efficace.\
    -   Le modèle optimise les portefeuilles sous contraintes.\
    -   Il construit la **frontière efficiente**, où le rapport rendement/risque est maximal.

## 3.2 Programme

```{r echo=TRUE}
#on definit un rendements cilblé pour l'optimisation
rendement_ciblé <- mean(mean_returns)
cov_matrix <- cov(returns)
cor_matrix <- cor(returns)

n_assets <- ncol(returns) # Nombre d'actifs
Dmat <- cov_matrix  # Matrice de covariance
dvec <- rep(0, n_assets)  # Vecteur objectif (minimiser la variance)
# Contraintes : somme des poids = 1, poids >= 0
Amat <- cbind(rep(1, n_assets), mean_returns, diag(n_assets)) 
# Rendement cible et contraintes
bvec <- c(1, rendement_ciblé, rep(0, n_assets)) 
# Résolution de l'optimisation quadratique
opt <- solve.QP(Dmat, dvec, Amat, bvec, meq = 1) 

#résultats
weights_min_var <- opt$solution
```

## 3.3 Résultats

```{r echo=FALSE}
barplot(
  weights_min_var * 100,
  names.arg = c("apple", "walmart", "meta", "nvidia"),
  col = rainbow(length(tickers)),
  main = "Répartition des poids de l'optimisation",
  ylab = "Poids (%)"
)
```

## 3.4 comparaison des ratios de sharpe avec optimisation et sans optimisation

**ratio de sharpe après optimisation :**

```{r echo=FALSE}
#ratio de sharpe du portefeuille
portfolio_return_min_var <- sum(weights_min_var * mean_returns)
portfolio_risk_min_var <- sqrt(t(weights_min_var) %*% cov_matrix %*% weights_min_var)
sharpe_ratio <- (portfolio_return_min_var) / portfolio_risk_min_var
sharpe_ratio
```

**ratio de sharpe sans optimisation optimisation :**

```{r echo=FALSE}
sharpe_equal_weights <- mean(colMeans(returns)) / sqrt(mean(diag(cov_matrix)))
sharpe_equal_weights
```

## 3.5 annualisation des résultats

```{r echo=FALSE}
# Calcul des moyennes et volatilités annualisées
mean_returns_annualized <- (1 + mean_returns)^252 - 1  # Rendements quotidiens annualisés (composés)
std_returns_annualized <- std_returns * sqrt(252)  # Écarts-types annualisés

# Calcul des performances annualisées du portefeuille
portfolio_return_annualized <- (1 + portfolio_return_min_var)^252 - 1  # Rendement annuel du portefeuille
portfolio_risk_annualized <- portfolio_risk_min_var * sqrt(252)  # Volatilité annuelle du portefeuille
sharpe_ratio_annualized <- portfolio_return_annualized / portfolio_risk_annualized  # Ratio de Sharpe annuel

# Ajout d'une matrice des résultats
results <- data.frame(
  Actif = c(tickers, "Portefeuille"),
  Poids = c(round(weights_min_var * 100, 2), 100),
  R_Annuel = c(round(mean_returns_annualized, 4), round(portfolio_return_annualized, 4)),
  Vol_Annuel = c(round(std_returns_annualized, 4), round(portfolio_risk_annualized, 4)),
  Ratio_Sharpe = c(round(mean_returns_annualized / std_returns_annualized, 4), round(sharpe_ratio_annualized, 4))
)

# Affichage des résultats
print(results)
```

Le portefeuille global atteint un rendement annuel de 94,08% avec une volatilité réduite à 16,89%, montrant l’effet positif de la diversification. Avec un ratio de Sharpe exceptionnel de 5.5706, le portefeuille surpasse largement les ratios des autres actifs pris individuellement, ce qui montre l’efficacité du programme d'optimisation.

## 3.6 frontière efficiente du portefeuille

```{r echo=FALSE}
# Étape 4 : Calcul de la frontière efficiente
portfolio_returns <- seq(min(mean_returns), max(mean_returns), length.out = 100)  # Rendements cibles
portfolio_risks <- sapply(portfolio_returns, function(target_return) {
  weights <- solve.QP(
    Dmat = cov_matrix,
    dvec = rep(0, n_assets),
    Amat = cbind(rep(1, n_assets), mean_returns, diag(n_assets)),
    bvec = c(1, target_return, rep(0, n_assets)),
    meq = 2
  )$solution
  sqrt(t(weights) %*% cov_matrix %*% weights)  # Risque (écart-type)
})

# Calcul des coordonnées du portefeuille optimisé
risk_optimized <- portfolio_risk_min_var
return_optimized <- portfolio_return_min_var

# Étape 5 : Tracé de la frontière efficiente
plot(
  portfolio_risks, portfolio_returns, type = "l", col = "red", lwd = 2,
  xlab = "Risque (Écart-Type)", ylab = "Rendement", main = "Frontière efficiente"
)

# Ajout du portefeuille optimisé
points(risk_optimized, return_optimized, col = "blue", pch = 19, cex = 1.5)
text(risk_optimized, return_optimized, labels = "Portefeuille Optimisé", pos = 4, col = "blue")

# Ajout d'une légende
legend(
  "bottomright", legend = c("Frontière efficiente", "Portefeuille Optimisé"),
  col = c("red", "blue"), lty = 1, pch = c(NA, 19), lwd = 2
)

```

## 3.7 Allocation par actif pour un budget de 500 euros

```{r echo=FALSE}
allocation <- round(weights_min_var * 500, 2)
names(allocation) <- c("apple", "walmart", "meta", "nvidia")
print(allocation)
```

Avec un budget de 500 euros, la majorité est investie dans Walmart (362,73 €) en raison de sa faible volatilité, suivi de Nvidia (92,53 €) pour son rendement élevé. Apple (24,31 €) et Meta (20,43 €) ont des allocations plus faibles, reflétant leur profil rendement/risque.

## 4. limites du modèle et de la présentation

-   Hypothèses trop simplifiées : normalité des rendements, stabilité des corrélations, souvent irréalistes.\
-   Dépendance aux données historiques : peu fiables pour prévoir les performances futures.\
-   Surpondération des actifs performants, réduisant la diversification.\
-   Poids égal pour gains et pertes, ignorant les priorités des investisseurs.\
-   Le portefeuille choisi, bien qu'optimal sur la frontière efficiente, n'est pas le portefeuille tangent, car nous avons privilégié une diversification équilibrée pour éviter l'exclusion de certains actifs.
